#include<linux/init.h>
#include<linux/kernel.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include<linux/slab.h>                 //kmalloc()
#include<linux/uaccess.h>              //copy_to/from_user()
#include <linux/ioctl.h>
#include<linux/proc_fs.h> //for getting the proc fs ralted functions and dada structures
#include <linux/err.h>

static int etx_open(struct inode *inode,struct file *filp);
static int etx_release(struct inode *inode,struct file *filp);
static ssize_t etx_read(struct file *filp,char __user buf,size_t len,loff_t off);
static ssize_t etx_write(struct file *filp,const char __user buf,size_t len,loff_t off);
static long etx_ioctl(struct file *filp,unsigned int cmd,unsigned long arg);

static struct file_operations f_ops=
{
	.owner=THIS_MODULE,
	.open=etx_open,
	.release=etx_release,
	.read=etx_read,
	.write=etx_write,
	.unlocked_ioctl=etx_ioctl,
};

//procfs operations
struct proc_ops proc_fops=
{
	proc_open=open_proc,
	proc_release=release_proc,
	proc_read=read_proc,
	proc_write=write_proc,
};

static int __init etx_init(void)
{
	//dynamic allocation of major number
	if(alloc_chrdev_region(&dev,0,1,"etx_Dev")<0)
	{
		pr_err("Dev major number error\n");
		return -1;
		
	}
	pr_info("Major = %d Minor = %d \n",MAJOR(dev), MINOR(dev));

	//cdev initiilization
	cdev_init(&etx_cdev,&f_ops);
	
	//cdev add
	if(IS_ERR(cdev_add(&etx_cdev,dev,1)))
	{
		pr_err("char device not added\n");
		goto r_class;
		
	}
			
	//class create
	if(IS_ERR(dev_class=class_create(THIS_MODULE,"etx_class")))
	{
		pr_err("class is failed to create\n");
		goto r_class;
	}
	//device create
	if(Is_ERR(device_create(&dev_class,NULL,dev,NULL,"etx_device")))
	{
		pr_err("device is failed to create\n");
		goto r_device;
	}
r_device:
	class_destroy(&etx_class);
r_class:
	unregister_chrdev_region(dev,1);
	return -1;
	
	
}
static void __exit  etx_exit(void)
{
	//proc del
	//delete device
	//delete class
	//cdev del
	//major number dealocate
	proc_remove();
	device_destroy(&dev_class,dev);
	class_destroy(&dev_class);
	cdev_del(&etx_cdev);
	unregister_chrdev_region(dev,1);
	pr_info("Device drive remove!!!\n");
	
}
module_init(etx_init);
module_exit(etx_exit);

